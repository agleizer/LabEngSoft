Guia de Desenvolvimento

1. VisÃ£o Geral

O Caminho FÃ¡cil Ã© um projeto Java Spring Boot executado em um ambiente padronizado via Docker, com banco de dados PostgreSQL 17 e JDK 21 (LTS).

Toda a configuraÃ§Ã£o Ã© feita para garantir que todos os integrantes do time desenvolvam e testem em condiÃ§Ãµes idÃªnticas, independentemente do sistema operacional.

Pilares da arquitetura

| Camada                      | Ferramenta                  | Responsabilidade principal                              |
| --------------------------- | --------------------------- | ------------------------------------------------------- |
| Ambiente idÃªntico       | Docker + Compose            | Mesmo sistema operacional, JDK 21 e PostgreSQL 17       |
| DependÃªncias Java       | Maven + Wrapper (`mvnw`)    | Controla bibliotecas e versÃ£o do Maven                  |
| ColaboraÃ§Ã£o e histÃ³rico | Git + GitHub + CI (Actions) | Versiona cÃ³digo, documenta e executa testes automÃ¡ticos |

VocÃª pode escolher como desenvolver:

* Fora do contÃªiner (Fluxo B) â€” usando o Maven e JDK locais
* Dentro do contÃªiner (Fluxo C) â€” ambiente isolado e controlado

> Regra de ouro: todos os commits e branches sÃ£o feitos fora do contÃªiner.
> O contÃªiner apenas roda e compila; ele nunca versiona cÃ³digo.

---

2. Estrutura do RepositÃ³rio


caminho-facil/
â”œâ”€â”€ .env.example               # Exemplo de variÃ¡veis de ambiente
â”œâ”€â”€ .env                       # Suas configuraÃ§Ãµes locais (nÃ£o versionado)
â”œâ”€â”€ Dockerfile                 # Define como o app Java Ã© construÃ­do e executado
â”œâ”€â”€ docker-compose.yml         # Orquestra app + banco de dados
â”œâ”€â”€ pom.xml                    # ConfiguraÃ§Ãµes Maven do projeto
â”œâ”€â”€ mvnw*, .mvn/               # Wrapper Maven (garante versÃ£o idÃªntica)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/java/...          # CÃ³digo-fonte Java (Spring Boot)
â”‚   â””â”€â”€ main/resources/...     # Templates, configs e HTML
â”œâ”€â”€ .github/workflows/ci.yml   # Pipeline CI (GitHub Actions)
â”œâ”€â”€ .gitignore, .editorconfig, .gitattributes
â””â”€â”€ README_DEV.md              # DocumentaÃ§Ã£o adicional


---

3. Fluxo de Trabalho do Time

3.1. Primeiro setup (somente uma vez)

bash
git clone https://github.com/<org>/<repo>.git
cd caminho-facil
cp .env.example .env
## se necessario, rode: sed -i 's/\r$//' mvnw
docker network create caminhofacil_net (APENAS DA PRIMEIRA VEZ, PARA CRIAR A REDE)
docker compose up --build
[NO SERVIDOR, RODAR DETACHED:] docker compose up --build -d


O Docker faz tudo:

* Baixa o Postgres 17 e inicializa o banco
* Compila o projeto Java (via Maven no contÃªiner)
* Executa o app acessÃ­vel em [http://localhost:8080](http://localhost:8080)

---

3.2. Editar cÃ³digo e versionar

1. Edite o cÃ³digo localmente (VS Code, IntelliJ etc.)

   > A pasta `src/` estÃ¡ montada no contÃªiner â€” as mudanÃ§as sÃ£o refletidas automaticamente.

2. Testar no Docker:

   bash
   docker compose build app
   docker compose up -d app
   docker compose logs -f app
   

   Isso recompila a imagem do app e mostra os logs em tempo real.

3. Versionar fora do contÃªiner:

   bash
   git status
   git add src/... pom.xml
   git commit -m "feat: nova rota /avaliacoes"
   git push origin minha-branch
   

> ğŸš« Nunca faÃ§a `git add` ou `git commit` dentro do contÃªiner.
> Ele Ã© efÃªmero â€” se for removido, o histÃ³rico se perde.

---

3.3. Quando alterar dependÃªncias

1. Edite o `pom.xml` (adicione ou atualize dependÃªncias).
2. FaÃ§a commit e push:

   bash
   git add pom.xml
   git commit -m "chore(deps): add springdoc"
   git push
   
3. Rebuild do app:

   bash
   docker compose build app && docker compose up -d app
   

O GitHub Actions recompila e roda testes automaticamente em cada push.

---

3.4. Branches e sincronizaÃ§Ã£o

| AÃ§Ã£o                   | Comando                                    |
| ---------------------- | ------------------------------------------ |
| Criar branch nova      | `git checkout -b feat/nova-funcionalidade` |
| Trocar de branch       | `git checkout main`                        |
| Atualizar branch local | `git pull origin main`                     |
| Enviar alteraÃ§Ãµes      | `git push origin feat/nova-funcionalidade` |

---

4. Modos de ExecuÃ§Ã£o

#Fluxo A â€“ Paridade total (build completo no Docker)

Mais estÃ¡vel, igual ao ambiente de produÃ§Ã£o e CI:

bash
docker compose up --build


Compila tudo dentro da imagem â€” ideal para validar o comportamento â€œrealâ€ do sistema.

---

#Fluxo B â€“ Desenvolvimento rÃ¡pido (Maven local)

Usa o JDK/Maven local, mas o banco via Docker:

bash
docker compose up -d db
./mvnw spring-boot:run


Permite hot reload com `spring-boot-devtools`.

---

#Fluxo C â€“ Desenvolvimento dentro do contÃªiner

Totalmente isolado, sem precisar instalar Maven localmente.

No `docker-compose.yml` adicione:

yaml
  dev:
    image: maven:3.9.11-eclipse-temurin-21
    working_dir: /workspace
    command: bash -lc "sleep infinity"
    volumes:
      - ./:/workspace
    env_file: [.env]
    depends_on:
      db:
        condition: service_healthy
    profiles: ["dev"]


Executar:

bash
docker compose --profile dev up -d db dev
docker compose exec dev bash     # entra no contÃªiner
./mvnw clean package
./mvnw spring-boot:run


Mesmo nesse fluxo, o cÃ³digo e o Git continuam sendo locais.

---

5. Comandos Essenciais

| AÃ§Ã£o             | Comando                                                   | O que faz                                |
| ---------------- | --------------------------------------------------------- | ---------------------------------------- |
| Subir app + DB   | `docker compose up --build`                               | Builda e inicia tudo                     |
| Subir sÃ³ o banco | `docker compose up -d db`                                 | Inicia apenas o Postgres                 |
| Rebuild do app   | `docker compose build app && docker compose up -d app`    | Recompila e relanÃ§a o app                |
| Ver logs         | `docker compose logs -f app`                              | Mostra logs em tempo real                |
| Parar tudo       | `docker compose down`                                     | Encerra contÃªineres                      |
| Resetar banco    | `docker compose down -v`                                  | Remove contÃªineres e volume de dados     |
| Entrar no app    | `docker compose exec app sh`                              | Abre shell no contÃªiner do app           |
| Acessar Postgres | `docker compose exec db psql -U postgres -d caminhofacil` | Abre o psql dentro do contÃªiner do banco |

---

6. Ciclo Completo de ContribuiÃ§Ã£o

1. Criar branch (`git checkout -b feat/...`)
2. Codar â†’ testar (`docker compose build app`)
3. Commitar fora do contÃªiner
4. Enviar (`git push`)
5. Abrir PR
6. CI valida build/testes
7. Merge na `main` com tudo verde âœ…

---

7. IntegraÃ§Ã£o ContÃ­nua (CI)

O pipeline `.github/workflows/ci.yml` executa automaticamente:

* Ambiente Ubuntu + JDK 21 + Postgres 17
* Comando:

  bash
  ./mvnw clean verify
  
* Marca o PR como â€œverdeâ€ se compilar e passar nos testes.

Nada manual: cada push gera uma build automÃ¡tica.

---

8. Por que nunca commitar dentro do contÃªiner

| Motivo                          | ExplicaÃ§Ã£o                                                                 |
| ------------------------------- | -------------------------------------------------------------------------- |
| ContÃªiner â‰  workspace real  | Ele Ã© efÃªmero. Ao parar, tudo se perde.                                    |
| Git nÃ£o reconhece metadados | Autoria, timestamps e histÃ³rico ficam incorretos.                          |
| Sem credenciais SSH         | Por seguranÃ§a, nÃ£o hÃ¡ tokens ou chaves dentro do contÃªiner.                |
| Volume jÃ¡ montado           | Tudo o que muda dentro jÃ¡ estÃ¡ refletido fora. Commits dentro sÃ£o inÃºteis. |

Resumo:
Edite e commite no host. Compile e teste onde quiser.

---

9. Cola RÃ¡pida de Setup

PrÃ©-requisitos:

* WSL 2 (Windows)
* Docker Desktop ativo (verificar com `docker info`)

bash
# Clonar e configurar
git clone <repo>
cd caminho-facil
cp .env.example .env

# Gerar wrapper Maven (se ainda nÃ£o existir)
docker run --rm -it -v ${PWD}:/workspace -w /workspace \
  maven:3.9.11-eclipse-temurin-21 mvn -N io.takari:maven:wrapper

## se necessario, rode: sed -i 's/\r$//' mvnw

# Subir tudo
docker compose up --build


---

10. Boas PrÃ¡ticas Gerais

* Use branches descritivas (`feat/`, `fix/`, `docs/`, etc.).
* Cada commit deve ser atÃ´mico e legÃ­vel.
* Nunca suba senhas reais (somente `.env.example`).
* Revise PRs antes do merge.
* Testes devem passar local e no CI.
* Atualize dependÃªncias em commits separados e com versÃµes fixas.
* Marque releases no GitHub (`v0.1.0`, `v0.2.0`, ...).

---

# Em resumo

> * Desenvolva fora do contÃªiner.
> * Compile dentro ou fora (Docker ou Maven local).
> * Commits sempre no host.
> * O CI garante que tudo compila e roda igual para todos.

---

Quer que eu inclua uma explicaÃ§Ã£o visual (diagrama em texto ou Mermaid) mostrando como os contÃªineres se relacionam (app â†” db â†” host â†” CI)? Isso tornaria o guia ainda mais didÃ¡tico.
